<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|Monaco:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta property="og:type" content="website">
<meta property="og:title" content="于成辉的技术博客">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="于成辉的技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="于成辉的技术博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title> 于成辉的技术博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">于成辉的技术博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">技术人生</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/03/13/2017-03-13-deeplearning-tensorflow-google-paper-introduction/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yuchenghui">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="于成辉的技术博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="于成辉的技术博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/13/2017-03-13-deeplearning-tensorflow-google-paper-introduction/" itemprop="url">
                  TensorFlow原理和实现框架简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-13T15:08:01+08:00">
                2017-03-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>TensorFlow是用来实现机器学习算法的一套接口设计，通过将数据流的模型映射到硬件平台上进行处理，运行的平台可以小到移动设备，比如手机，大到数以千计运行着GPU显卡的服务器。目前被广泛的应用于深度学习领域，语音识别，计算机视觉，自然语言处理等。</p>
<h1 id="基本概念介绍"><a href="#基本概念介绍" class="headerlink" title="基本概念介绍"></a><strong>基本概念介绍</strong></h1><h2 id="graph"><a href="#graph" class="headerlink" title="graph"></a><strong>graph</strong></h2><p>graph表示用于计算的数据流，可以称之为位图，</p>
<h2 id="nodes"><a href="#nodes" class="headerlink" title="nodes"></a><strong>nodes</strong></h2><p>组成grap的基本单位，可以存储以及更新状态信息。组成graph的每个node都可以有多个输入和输出，这些输入和输出就是对实例的operation</p>
<h2 id="tensor"><a href="#tensor" class="headerlink" title="tensor"></a><strong>tensor</strong></h2><p>张量，在位图graph边缘节点的数据流，具体就是一些多维的数组。</p>
<h1 id="TensorFlow的操作小结"><a href="#TensorFlow的操作小结" class="headerlink" title="TensorFlow的操作小结"></a><strong>TensorFlow的操作小结</strong></h1><p>主要分为：数值，数组，矩阵，状态，神经网络，检查，队列和同步，控制流等类型的操作。</p>
<img src="/images/TensorFlow/operation.jpg">

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/24/2017-02-24-neutron-ml2-Hierarchical-port-binding/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yuchenghui">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="于成辉的技术博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="于成辉的技术博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/24/2017-02-24-neutron-ml2-Hierarchical-port-binding/" itemprop="url">
                  neutron端口的层次化绑定原理和机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-24T10:43:06+08:00">
                2017-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/云计算/" itemprop="url" rel="index">
                    <span itemprop="name">云计算</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="neutron的层次化绑定介绍"><a href="#neutron的层次化绑定介绍" class="headerlink" title="neutron的层次化绑定介绍"></a><strong>neutron的层次化绑定介绍</strong></h1><p>neutron的层次化绑定主要是指一个层次化的虚拟化网络包括不同的网络段，在不同的level上的网络类型也不一样，包括VLAN，VXLAN和GRE等类型，比如在核心交换机和ToR交换机之间可能是静态的VXLAN的网络封装，而ToR交换机和openstack的计算节点之间可以部署动态的VLAN网络。这种静态的VXAN的模式并不是neutron的ML2里面的vxlan_type类型，而是物理的VXLAN包的处理</p>
<img src="/images/neutron-hierarchical-binding-ports/hierarchical-description.jpg">
<h1 id="neutron的层次化绑定原理和机制"><a href="#neutron的层次化绑定原理和机制" class="headerlink" title="neutron的层次化绑定原理和机制"></a><strong>neutron的层次化绑定原理和机制</strong></h1><p>neutron通过将port绑定到不同层次的mechanism drivers和network上去来实现层次化绑定机制，比如从ToR交换机到计算节点的网桥，使用厂商的SND mechanism driver来实现静态VXLAN的绑定，而在计算节点上，通过OVS的mechanism driver来实现动态VLAN的绑定。也就是说实现neutron的层次化绑定的关键在于port的设置和使用。</p>
<p>相关代码查看：neutron/neutron/plugins/ml2/driver_api.py</p>
<h2 id="层次化绑定的初始化以及创建过程"><a href="#层次化绑定的初始化以及创建过程" class="headerlink" title="层次化绑定的初始化以及创建过程"></a><strong>层次化绑定的初始化以及创建过程</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">class PortContext(object):</div><div class="line">    @abc.abstractmethod</div><div class="line">    def continue_binding(self, segment_id, next_segments_to_bind):</div><div class="line">        &quot;&quot;&quot;Continue binding the port with different segments.</div><div class="line"></div><div class="line">        :param segment_id: Network segment partially bound for the port.</div><div class="line">        :param next_segments_to_bind: Segments to continue binding with.</div><div class="line"></div><div class="line">        This method is called by MechanismDriver.bind_port to indicate</div><div class="line">        it was able to partially bind the port, but that one or more</div><div class="line">        additional mechanism drivers are required to complete the</div><div class="line">        binding. The segment_id must identify an item in the current</div><div class="line">        value of the segments_to_bind property. The list of segments</div><div class="line">        IDs passed as next_segments_to_bind identify dynamic (or</div><div class="line">        static) segments of the port&apos;s network that will be used to</div><div class="line">        populate segments_to_bind for the next lower level of a</div><div class="line">        hierarchical binding.</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        pass</div><div class="line"></div><div class="line">    @abc.abstractproperty</div><div class="line">    def segments_to_bind(self):</div><div class="line">        &quot;&quot;&quot;Return the list of segments with which to bind the port.</div><div class="line"></div><div class="line">        This property returns the list of segment dictionaries with</div><div class="line">        which the mechanism driver may bind the port. When</div><div class="line">        establishing a top-level binding, these will be the port&apos;s</div><div class="line">        network&apos;s static segments. For each subsequent level, these</div><div class="line">        will be the segments passed to continue_binding by the</div><div class="line">        mechanism driver that bound the level above.</div><div class="line"></div><div class="line">        This property is only valid within calls to</div><div class="line">        MechanismDriver.bind_port. It returns None otherwise.</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        pass</div><div class="line"></div><div class="line">    @abc.abstractmethod</div><div class="line">    def set_binding(self, segment_id, vif_type, vif_details,</div><div class="line">                    status=None):</div><div class="line">        &quot;&quot;&quot;Set the bottom-level binding for the port.</div><div class="line"></div><div class="line">        :param segment_id: Network segment bound for the port.</div><div class="line">        :param vif_type: The VIF type for the bound port.</div><div class="line">        :param vif_details: Dictionary with details for VIF driver.</div><div class="line">        :param status: Port status to set if not None.</div><div class="line"></div><div class="line">        This method is called by MechanismDriver.bind_port to indicate</div><div class="line">        success and specify binding details to use for port. The</div><div class="line">        segment_id must identify an item in the current value of the</div><div class="line">        segments_to_bind property.</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        pass</div></pre></td></tr></table></figure>
<p>mechanism driver通常会在使用<code>set_binding()</code>方法时调用<code>bind_port()</code>方法，而层次化绑定<code>continue_binding()</code>方法就伴随调用<code>bind_port()</code>方法来进行端口绑定。</p>
<ul>
<li>如果mechanism driver可以完成全部的端口绑定，那么就直接调用<code>PortContext.set_binding(segment_id, vif_type, vif_details, status)</code>方法</li>
<li>如果mechanism driver可以完成部分层级的端口绑定，那么就调用<code>continue_binding(segment_id, next_segments_to_bind)</code>方法</li>
<li>如果mechanism driver不能完成端口绑定，那么都不会调用上述两种方法</li>
</ul>
<h3 id="代码调用机制"><a href="#代码调用机制" class="headerlink" title="代码调用机制"></a><strong>代码调用机制</strong></h3><p>segment_id通过<code>set_binding()</code>方法传递给<code>continue_binding()</code>方法，来表明driver正在使用该网段，而network的新的segment就可以用来进行端口绑定的下一阶段，一般来说就是指动态的绑定。mechanism driver用来绑定<code>PortContext.network.network_segments</code>正在使用的静态的网络段。在绑定的初始阶段，<code>PortContext.segments_to_bind()</code>会包含和<code>PortContext.network.network_segments</code>相同的网络段，在接下来的阶段，<code>PortContext.segments_to_bind()</code>就会通过之前的driver获取网络段作为next_segments_to_bind来调用<code>PortContext.continue_binding()</code>。</p>
<h3 id="排错处理"><a href="#排错处理" class="headerlink" title="排错处理"></a><strong>排错处理</strong></h3><p>在端口绑定的任何阶段，对于那些已经在高层级绑定过端口的driver，如果还要调用当前层级的network segments，那么就会被去除掉。在层次化网络绑定中，相同的driver可以通过使用不同的segments来在不同的层级level中进行部分绑定，但是不允许使用相同的segments。另外，如果超过网络层级的数目，端口绑定也会失败。</p>
<h2 id="层次化绑定信息查询"><a href="#层次化绑定信息查询" class="headerlink" title="层次化绑定信息查询"></a><strong>层次化绑定信息查询</strong></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">class PortContext(object):</div><div class="line"></div><div class="line">    @abc.abstractproperty</div><div class="line">    def binding_levels(self):</div><div class="line">        &quot;&quot;&quot;Return dictionaries describing the current binding levels.</div><div class="line"></div><div class="line">        This property returns a list of dictionaries describing each</div><div class="line">        binding level if the port is bound or partially bound, or None</div><div class="line">        if the port is unbound. Each returned dictionary contains the</div><div class="line">        name of the bound driver under the BOUND_DRIVER key, and the</div><div class="line">        bound segment dictionary under the BOUND_SEGMENT key.</div><div class="line"></div><div class="line">        The first entry (index 0) describes the top-level binding,</div><div class="line">        which always involves one of the port&apos;s network&apos;s static</div><div class="line">        segments. In the case of a hierarchical binding, subsequent</div><div class="line">        entries describe the lower-level bindings in descending order,</div><div class="line">        which may involve dynamic segments. Adjacent levels where</div><div class="line">        different drivers bind the same static or dynamic segment are</div><div class="line">        possible. The last entry (index -1) describes the bottom-level</div><div class="line">        binding that supplied the port&apos;s binding:vif_type and</div><div class="line">        binding:vif_details attribute values.</div><div class="line"></div><div class="line">        Within calls to MechanismDriver.bind_port, descriptions of the</div><div class="line">        levels above the level currently being bound are returned.</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        pass</div><div class="line"></div><div class="line">    @abc.abstractproperty</div><div class="line">    def original_binding_levels(self):</div><div class="line">        &quot;&quot;&quot;Return dictionaries describing the original binding levels.</div><div class="line"></div><div class="line">        This property returns a list of dictionaries describing each</div><div class="line">        original binding level if the port was previously bound, or</div><div class="line">        None if the port was unbound. The content is as described for</div><div class="line">        the binding_levels property.</div><div class="line"></div><div class="line">        This property is only valid within calls to</div><div class="line">        update_port_precommit and update_port_postcommit. It returns</div><div class="line">        None otherwise.</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        pass</div><div class="line"></div><div class="line">    @abc.abstractproperty</div><div class="line">    def top_bound_segment(self):</div><div class="line">        &quot;&quot;&quot;Return the current top-level bound segment dictionary.</div><div class="line"></div><div class="line">        This property returns the current top-level bound segment</div><div class="line">        dictionary, or None if the port is unbound. For a bound port,</div><div class="line">        top_bound_segment is equivalent to</div><div class="line">        binding_levels[0][BOUND_SEGMENT], and returns one of the</div><div class="line">        port&apos;s network&apos;s static segments.</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        pass</div><div class="line"></div><div class="line">    @abc.abstractproperty</div><div class="line">    def original_top_bound_segment(self):</div><div class="line">        &quot;&quot;&quot;Return the original top-level bound segment dictionary.</div><div class="line"></div><div class="line">        This property returns the original top-level bound segment</div><div class="line">        dictionary, or None if the port was previously unbound. For a</div><div class="line">        previously bound port, original_top_bound_segment is</div><div class="line">        equivalent to original_binding_levels[0][BOUND_SEGMENT], and</div><div class="line">        returns one of the port&apos;s network&apos;s static segments.</div><div class="line"></div><div class="line">        This property is only valid within calls to</div><div class="line">        update_port_precommit and update_port_postcommit. It returns</div><div class="line">        None otherwise.</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        pass</div><div class="line"></div><div class="line">    @abc.abstractproperty</div><div class="line">    def bottom_bound_segment(self):</div><div class="line">        &quot;&quot;&quot;Return the current bottom-level bound segment dictionary.</div><div class="line"></div><div class="line">        This property returns the current bottom-level bound segment</div><div class="line">        dictionary, or None if the port is unbound. For a bound port,</div><div class="line">        bottom_bound_segment is equivalent to</div><div class="line">        binding_levels[-1][BOUND_SEGMENT], and returns the segment</div><div class="line">        whose binding supplied the port&apos;s binding:vif_type and</div><div class="line">        binding:vif_details attribute values.</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        pass</div><div class="line"></div><div class="line">    @abc.abstractproperty</div><div class="line">    def original_bottom_bound_segment(self):</div><div class="line">        &quot;&quot;&quot;Return the original bottom-level bound segment dictionary.</div><div class="line"></div><div class="line">        This property returns the orignal bottom-level bound segment</div><div class="line">        dictionary, or None if the port was previously unbound. For a</div><div class="line">        previously bound port, original_bottom_bound_segment is</div><div class="line">        equivalent to original_binding_levels[-1][BOUND_SEGMENT], and</div><div class="line">        returns the segment whose binding supplied the port&apos;s previous</div><div class="line">        binding:vif_type and binding:vif_details attribute values.</div><div class="line"></div><div class="line">        This property is only valid within calls to</div><div class="line">        update_port_precommit and update_port_postcommit. It returns</div><div class="line">        None otherwise.</div><div class="line">        &quot;&quot;&quot;</div><div class="line">        pass</div></pre></td></tr></table></figure>
<p><code>binding_levels()</code>和<code>original_binding_levels()</code>方法返回描述端口绑定的详细信息，BOUND_DRIVER和BOUND_SEGMENT字段来进行描述。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/02/14/2017-02-14-neutron-snat-introduction/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yuchenghui">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="于成辉的技术博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="于成辉的技术博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/14/2017-02-14-neutron-snat-introduction/" itemprop="url">
                  neutron的SNAT和非SNAT功能在GBP环境下的对比分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-02-14T15:39:18+08:00">
                2017-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/云计算/" itemprop="url" rel="index">
                    <span itemprop="name">云计算</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>在目前neutron服务中，对于路由的router gateway external network可以有SNAT和非SNAT方式两种，下面就对着两种方法的原理和机制进行详细的讨论。</p>
<p><strong><em>测试条件</em></strong><br>虚机地址：192.168.55.5<br>L3 policy（路由域）的路由网管：172.21.12.244</p>
<img src="/images/neutron-snat-introduction/icmp.JPG">
<h1 id="neutron中的SNAT服务原理和运行机制"><a href="#neutron中的SNAT服务原理和运行机制" class="headerlink" title="neutron中的SNAT服务原理和运行机制"></a><strong>neutron中的SNAT服务原理和运行机制</strong></h1><h2 id="路由命名空间"><a href="#路由命名空间" class="headerlink" title="路由命名空间"></a><strong>路由命名空间</strong></h2><p>SNAT的使用场景主要是在计算节点创建的虚机的网络流量需要到达外网，在虚拟路由上进行SNAT转换，外网出去的地址是虚机SNAT转换后的IP地址，具体可以查看路由命名空间里面的iptables规则。<br>首先查看路由命名空间的port信息</p>
<img src="/images/neutron-snat-introduction/no-snat-ip-netns.JPG">
<p>可以看到虚机的内部网管地址在qr-xxxxx上，而路由的外部网管地址在qg-xxxxxx上，虚机的网络流量如果要出去，那么就需要经过上述两个port。</p>
<h2 id="OVS桥上的流表规则"><a href="#OVS桥上的流表规则" class="headerlink" title="OVS桥上的流表规则"></a><strong>OVS桥上的流表规则</strong></h2><p>这里连接外部的网卡是eth0，而br-ex连接外部的物理网卡，所以要想理清虚机出外网的流表规则就需要查看br-ex和br-int上的流表。</p>
<h3 id="br-ex"><a href="#br-ex" class="headerlink" title="br-ex"></a>br-ex</h3><p>首先查看br-ex上的port（patch：br-ex）是否有VLAN号，这个VLAN主要就是外部交换机连接的端口VLAN，这样外部硬件交换机可以准确的实现网络的二层可达。</p>
<img src="/images/neutron-snat-introduction/br-ex-tag.JPG">
<p>可以看到port（br-ex）上存在一个tag=195的VLAN号，这样从br-ex上出去的网络流量都带有VLAN=195，而外部网卡进来的带有VLAN=195的数据包就可以到达br-ex。</p>
<p>然后查看br-ex的流表信息：</p>
<img src="/images/neutron-snat-introduction/br-ex-flows.JPG">
<p>可以看到，只要是内部的VLAN=2的数据包进到br-ex上，那么br-ex就会将VLAN号修改为195发出到物理网卡上去。</p>
<h3 id="br-int"><a href="#br-int" class="headerlink" title="br-int"></a>br-int</h3><p>查看br-int上的流表规则：</p>
<img src="/images/neutron-snat-introduction/br-int-flows.JPG">
<p>可以看到主要是从外部过来的带有VLAN=195的数据包，就会将其修改为VLAN=2的数据包进到br-tun上处理，这个包肯定就是进入虚机的网络数据包。这样网络流量从出去到进入到虚机里面的流表就会进行删除处理，来打通网络。</p>
<h1 id="neutron中的非SNAT服务原理和运行机制"><a href="#neutron中的非SNAT服务原理和运行机制" class="headerlink" title="neutron中的非SNAT服务原理和运行机制"></a><strong>neutron中的非SNAT服务原理和运行机制</strong></h1><h2 id="操作方式"><a href="#操作方式" class="headerlink" title="操作方式"></a><strong>操作方式</strong></h2><p>需要在命令行上操作路由的外部网关</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">neutron router-gateway-set --disable-snat ROUTER EXTERNAL-NETWORK     //就可以将SNAT功能去掉</div></pre></td></tr></table></figure>
<h2 id="iptables规则"><a href="#iptables规则" class="headerlink" title="iptables规则"></a><strong>iptables规则</strong></h2><p>在路由的命名空间里查看iptables</p>
<img src="/images/neutron-snat-introduction/iptables.JPG">
<p>可以看到并没有相关的192.168.55.5转172.21.12.244的SNAT的iptables规则，说明现在已经是非SNAT模式。</p>
<h2 id="抓包测试"><a href="#抓包测试" class="headerlink" title="抓包测试"></a><strong>抓包测试</strong></h2><p>这里其实存在一个细节问题，就是虚机ping外网的时候，需要有一个ICMP的回包，这时候路由是怎么区分和识别这一ICMP的回包的呢，主要是通过物理节点的路由表，这个路由就需要将路由的外部公网地址好虚机的网络段打通。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip route add 192.168.55.0/24 via 172.21.12.244 dev br-ex</div></pre></td></tr></table></figure></p>
<img src="/images/neutron-snat-introduction/no-snat-route.JPG">
<p>这样就可以在非SNAT下虚机的流量出外网。</p>
<p><strong>在虚机ping外网地址</strong></p>
<p><em>qr-xxxxxx上的数据包</em></p>
<img src="/images/neutron-snat-introduction/arp-name-qr.JPG">
<p><em>qg-xxxxxx上的数据包</em></p>
<img src="/images/neutron-snat-introduction/no-snat-qg.JPG">

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/01/05/2017-01-05-openstack-network-classification/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yuchenghui">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="于成辉的技术博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="于成辉的技术博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/05/2017-01-05-openstack-network-classification/" itemprop="url">
                  openstack中的network类型和属性介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-05T09:39:57+08:00">
                2017-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/云计算/" itemprop="url" rel="index">
                    <span itemprop="name">云计算</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>主要介绍一些有关openstack中的网路类型，包括provider network、project network、physical network等。</p>
<h1 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a><strong>网络分类</strong></h1><table>
<thead>
<tr>
<th style="text-align:left">分类</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">virtual network</td>
<td style="text-align:left">主要是openvswitch和Linux bridge实现的L2虚拟网络，通过虚拟网卡（vNIC）和计算虚机以及不同的网络agent联通</td>
</tr>
<tr>
<td style="text-align:left">physical network</td>
<td style="text-align:left">将不同的虚拟主机（计算节点，控制节点或者网络节点）以及其他网络资源连通起来，并且支持不同的虚拟网络</td>
</tr>
<tr>
<td style="text-align:left">project network</td>
<td style="text-align:left">由project或者administrator创建的虚拟网络，网络的物理映射关系对于所属的project是隐藏的</td>
</tr>
<tr>
<td style="text-align:left">provider network</td>
<td style="text-align:left">由administrator创建的虚拟网络，直接映射到数据中心的物理网络资源，project可以直接和provider networks连通，可以配置预设好的vlan，这样配置VLAN的虚机也可以作为数据中心的bare-metal host使用</td>
</tr>
<tr>
<td style="text-align:left">VLAN network</td>
<td style="text-align:left">符合IEEE 802.1Q标准的vlan虚拟网络，每个VLAN network都包含IEEE 802.1Q headers。不同VLAN网络之间共享同一个physical network，但是通过VID号在L2层相互之间隔离，VID范围为1 ~ 4096</td>
</tr>
<tr>
<td style="text-align:left">flat network</td>
<td style="text-align:left">存在于physical network中的一个不包含IEEE 802.1Q headers的虚拟网络，L2层打通网络</td>
</tr>
<tr>
<td style="text-align:left">local network</td>
<td style="text-align:left">只能保证host之间的通信，而不能连接外部网络</td>
</tr>
<tr>
<td style="text-align:left">GRE network</td>
<td style="text-align:left">实现GRE协议，通过tunnels相互连接，并通过L3层路由来和host打通，不能够直接和physical network连通</td>
</tr>
<tr>
<td style="text-align:left">Virtual Extensible LAN (VXLAN) network</td>
<td style="text-align:left">实现VXLAN的在于L2和L3之上的overlay网络</td>
</tr>
</tbody>
</table>
<p>在neutron中，ML2，openvswitch，Linux bridge支持VLAN，flat，local network，只有ML2，openvswitch支持GRE和VXLAN</p>
<h1 id="网络属性"><a href="#网络属性" class="headerlink" title="网络属性"></a><strong>网络属性</strong></h1><table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th>类型</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">provider: network_type</td>
<td>String</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">flat, vlan, local, gre和vxlan，administrators可以实现所有的网络类型，而projects只能实现vlan, gre, vxlan和local</td>
</tr>
<tr>
<td style="text-align:left">provider: physical_network</td>
<td>String</td>
<td style="text-align:left">default(配置文件里预设为default，provider:network_type是flat或者vlan)</td>
<td style="text-align:left">支持flat和vlan，不支持vxlan和gre</td>
</tr>
<tr>
<td style="text-align:left">provider:segmentation_id</td>
<td>Integer</td>
<td style="text-align:left">N/A</td>
<td style="text-align:left">支持vlan，vxlan和gre，不支持flat和local</td>
</tr>
</tbody>
</table>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/04/2016-12-04-mac-go-IDEA-configure/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yuchenghui">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="于成辉的技术博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="于成辉的技术博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/04/2016-12-04-mac-go-IDEA-configure/" itemprop="url">
                  Mac + IntelliJ IDEA上的go编程环境配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-04T21:43:39+08:00">
                2016-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/go/" itemprop="url" rel="index">
                    <span itemprop="name">go</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="首先下载IntelliJ-IDEA-，在mac上安装好"><a href="#首先下载IntelliJ-IDEA-，在mac上安装好" class="headerlink" title="首先下载IntelliJ IDEA()，在mac上安装好"></a><strong>首先下载IntelliJ IDEA()，在mac上安装好</strong></h2><h2 id="IntelliJ-IDEA中安装go的插件"><a href="#IntelliJ-IDEA中安装go的插件" class="headerlink" title="IntelliJ IDEA中安装go的插件"></a><strong>IntelliJ IDEA中安装go的插件</strong></h2><p>Preferences &gt; Plugins &gt; Browse repositories<br>然后搜索go，找到go的插件后安装，安装成功后就会在IDEA中得到相关的配置。</p>
<h2 id="mac中golang环境的安装和配置"><a href="#mac中golang环境的安装和配置" class="headerlink" title="mac中golang环境的安装和配置"></a><strong>mac中golang环境的安装和配置</strong></h2><h3 id="go软件包的安装"><a href="#go软件包的安装" class="headerlink" title="go软件包的安装"></a><strong>go软件包的安装</strong></h3><p>由于mac中软件包是通过homebrew来管理的，所以为了后续的升级和配置应该使用homebrew来安装golang，命令也比较简单<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install go</div></pre></td></tr></table></figure></p>
<p>就可以安装好go的环境了</p>
<h3 id="GOPATH的配置"><a href="#GOPATH的配置" class="headerlink" title="GOPATH的配置"></a><strong>GOPATH的配置</strong></h3><p>GOPATH路径主要是用来存放go的源代码，编译生成的文件以及可执行文件等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go env</div></pre></td></tr></table></figure>
<p>可以显示go的所有环境配置，如果没有提前配置GOPATH可以看到这一项为空。<br>在.zshrc或者.bashrc中添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export GOPATH=/$HOME/mygo</div></pre></td></tr></table></figure></p>
<p>这里的mygo表示自己创建的go项目目录。GOPATH允许多个目录，当有多个目录时，请注意分隔符。</p>
<p>以上 $GOPATH 目录约定有三个子目录：</p>
<ul>
<li>src 存放源代码（比如：.go .c .h .s等）</li>
<li>pkg 编译后生成的文件（比如：.a）</li>
<li>bin 编译后生成的可执行文件（为了方便，可以把此目录加入到 $PATH 变量中，如果有多个gopath，那么使用${GOPATH//://bin:}/bin添加所有的bin目录）</li>
</ul>
<p>这样就配置好了GOPATH。</p>
<h2 id="IntelliJ-IDEA中golang环境的安装和配置"><a href="#IntelliJ-IDEA中golang环境的安装和配置" class="headerlink" title="IntelliJ IDEA中golang环境的安装和配置"></a><strong>IntelliJ IDEA中golang环境的安装和配置</strong></h2><h3 id="IntelliJ-IDEA中安装go的插件-1"><a href="#IntelliJ-IDEA中安装go的插件-1" class="headerlink" title="IntelliJ IDEA中安装go的插件"></a><strong>IntelliJ IDEA中安装go的插件</strong></h3><p>Preferences &gt; Plugins &gt; Browse repositories<br>然后搜索go，找到go的插件后安装，安装成功后就会在IDEA中得到相关的配置。</p>
<h3 id="IntelliJ-IDEA中配置golang的SDK"><a href="#IntelliJ-IDEA中配置golang的SDK" class="headerlink" title="IntelliJ IDEA中配置golang的SDK"></a><strong>IntelliJ IDEA中配置golang的SDK</strong></h3><p>file &gt; Project Structure &gt; SDKs<br>点击+，添加go的SDK，一般路径就是默认的/usr/local/Cellar/go/1.7.3/libexec，这样就配置好SDK的环境了。</p>
<h3 id="IntelliJ-IDEA中新建go项目的配置"><a href="#IntelliJ-IDEA中新建go项目的配置" class="headerlink" title="IntelliJ IDEA中新建go项目的配置"></a><strong>IntelliJ IDEA中新建go项目的配置</strong></h3><p>在创建go project的时候，IDEA会提示设置GOPATH，这时候就把之前在mac上设置的GOPATH添加进去就可以了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/26/2016-11-26-vxlan-offload-experiment/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yuchenghui">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="于成辉的技术博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="于成辉的技术博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/26/2016-11-26-vxlan-offload-experiment/" itemprop="url">
                  网卡VXLAN offload性能验证方案设计和实验
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-26T11:53:22+08:00">
                2016-11-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/云计算/" itemprop="url" rel="index">
                    <span itemprop="name">云计算</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="测试整体概述"><a href="#测试整体概述" class="headerlink" title="测试整体概述"></a><strong>测试整体概述</strong></h2><h3 id="网包流向"><a href="#网包流向" class="headerlink" title="网包流向"></a><strong>网包流向</strong></h3><table>
<thead>
<tr>
<th>Traffic Flow Type</th>
<th>Data Path</th>
</tr>
</thead>
<tbody>
<tr>
<td>VXLAN-to-VXLAN over bridge</td>
<td>client host -&gt; linux bridge -&gt; br-int -&gt; eth1 -&gt; leaf switch -&gt; eth1 -&gt; br-int -&gt; linux bridge -&gt; server host</td>
</tr>
</tbody>
</table>
<h3 id="整体原理框图"><a href="#整体原理框图" class="headerlink" title="整体原理框图"></a><strong>整体原理框图</strong></h3><img src="/images/vxlan-offload/experience.png">
<h2 id="测试验证步骤"><a href="#测试验证步骤" class="headerlink" title="测试验证步骤"></a><strong>测试验证步骤</strong></h2><p>Netperf工具主要用来产生客户端和服务端的TCP流量，它是测试网络的一个轻量级的用户进程，主要包括以下部分：</p>
<p>Netperf—用户级进程，用来连接服务端并产生流量</p>
<p>Netserver—用户级进程，用来监听个接受请求连接。</p>
<p>查看offload信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">[root@node-1 vxlan-offload]$ ethtool -k ethX</div><div class="line">Features for eno16777736:</div><div class="line">rx-checksumming: off</div><div class="line">tx-checksumming: on</div><div class="line">        tx-checksum-ipv4: off [fixed]</div><div class="line">		tx-checksum-ip-generic: on</div><div class="line">        tx-checksum-ipv6: off [fixed]</div><div class="line">		tx-checksum-fcoe-crc: off [fixed]</div><div class="line">		tx-checksum-sctp: off [fixed]</div><div class="line">scatter-gather: on</div><div class="line">        tx-scatter-gather: on</div><div class="line">		tx-scatter-gather-fraglist: off [fixed]</div><div class="line">tcp-segmentation-offload: on</div><div class="line">        tx-tcp-segmentation: on</div><div class="line">		tx-tcp-ecn-segmentation: off [fixed]</div><div class="line">		tx-tcp6-segmentation: off [fixed]</div><div class="line">udp-fragmentation-offload: off [fixed]</div><div class="line">generic-segmentation-offload: on</div><div class="line">generic-receive-offload: on</div><div class="line">large-receive-offload: off [fixed]</div><div class="line">rx-vlan-offload: on</div><div class="line">tx-vlan-offload: on [fixed]</div><div class="line">ntuple-filters: off [fixed]</div><div class="line">receive-hashing: off [fixed]</div><div class="line">highdma: off [fixed]</div><div class="line">rx-vlan-filter: on [fixed]</div><div class="line">vlan-challenged: off [fixed]</div><div class="line">tx-lockless: off [fixed]</div><div class="line">netns-local: off [fixed]</div><div class="line">tx-gso-robust: off [fixed]</div><div class="line">tx-fcoe-segmentation: off [fixed]</div><div class="line">tx-gre-segmentation: off [fixed]</div><div class="line">tx-ipip-segmentation: off [fixed]</div><div class="line">tx-sit-segmentation: off [fixed]</div><div class="line">tx-udp_tnl-segmentation: off [fixed]  //该选项的状态代表着网卡的VXLAN offload功能</div><div class="line">tx-mpls-segmentation: off [fixed]</div><div class="line">fcoe-mtu: off [fixed]</div><div class="line">tx-nocache-copy: off</div><div class="line">loopback: off [fixed]</div><div class="line">rx-fcs: off</div><div class="line">rx-all: off</div><div class="line">tx-vlan-stag-hw-insert: off [fixed]</div><div class="line">rx-vlan-stag-hw-parse: off [fixed]</div><div class="line">rx-vlan-stag-filter: off [fixed]</div><div class="line">busy-poll: off [fixed]</div></pre></td></tr></table></figure>
<p>可以看到启动VXLAN offload功能的tx-udp_tnl-segmentation带有[fixed]，意味这VXLAN的offload功能不可用，目前该网卡并不支持VXLAN的offload功能。</p>
<h2 id="验证测试"><a href="#验证测试" class="headerlink" title="验证测试"></a><strong>验证测试</strong></h2><p>Netperf可以用来获取client端和server端的throughput和CPU的利用率，网络的吞吐量，建立时间等方面，测试内容主要是用于测试eth网卡的VXLAN offload的性能，后续的测试项可以按照下面表格中的参数进行测试，分为两种情况，即<strong>开启NIC的VXLAN offload功能</strong>和<strong>不开启NIC的VXLAN offload功能</strong>。</p>
<table>
<thead>
<tr>
<th>socket发送与接收缓存大小</th>
<th>client向server端发送测试分组的大小</th>
<th>client端CPU利用率</th>
<th>server端CPU利用率</th>
<th>网络吞吐量</th>
<th>网络响应时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>128K</td>
<td>4K</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>128K</td>
<td>8K</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>128K</td>
<td>32K</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>56K</td>
<td>4K</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>56K</td>
<td>8K</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>56K</td>
<td>32K</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>32K</td>
<td>4K</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>32K</td>
<td>8K</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>32K</td>
<td>32K</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>4M</td>
<td>4K</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>4M</td>
<td>8K</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>4M</td>
<td>32K</td>
<td>–</td>
<td>–</td>
<td>–</td>
<td>–</td>
</tr>
</tbody>
</table>
<h3 id="相关shell测试脚本已列出"><a href="#相关shell测试脚本已列出" class="headerlink" title="相关shell测试脚本已列出"></a><strong>相关shell测试脚本已列出</strong></h3><p><a href="https://github.com/chenghuiyu/programFiles/tree/master/vxlan_offload_shell/netperf_tcp_stream.sh" target="_blank" rel="external">TCP stream testing</a></p>
<p><a href="https://github.com/chenghuiyu/programFiles/tree/master/vxlan_offload_shell/netperf_udp_stream.sh" target="_blank" rel="external">UDP stream testing</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/26/2016-11-26-neutron-vxlan-offload/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yuchenghui">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="于成辉的技术博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="于成辉的技术博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/26/2016-11-26-neutron-vxlan-offload/" itemprop="url">
                  NIC的VXLAN offload和neutron结合的运行机制详解
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-26T11:52:32+08:00">
                2016-11-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/云计算/" itemprop="url" rel="index">
                    <span itemprop="name">云计算</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>Neutron中使用网卡VXLAN的offload技术两种场景，一种是单独使用Linux bridge的情况，另外一种就是OVS场景下的应用，之所以考虑这两种场景主要从以下方面考虑：</p>
<p><strong>（1）Linux bridge</strong>：这里的主要是指openstack中单独使用Linux bridge agent，即Linux bridge+VXLAN的情况，社区里其实也提到过OVS一些稳定性的问题，比如Kernetl panics 1.10、ovs-switched segfaults 1.11、广播风暴和Data corruption 2.01等，而Linux bridge相对稳定一些，所以这种Linux bridge+VXLAN的场景在实际中也是经常用到的。</p>
<p><strong>（2）OVS</strong>：这种情景就是使用OVS agent的情况，结合NIC VXLAN的offload进行具体的分析。</p>
<h2 id="Neutron-VXLAN-Linux-bridge中的NIC-VXLAN-offload"><a href="#Neutron-VXLAN-Linux-bridge中的NIC-VXLAN-offload" class="headerlink" title="Neutron VXLAN + Linux bridge中的NIC VXLAN offload"></a><strong>Neutron VXLAN + Linux bridge中的NIC VXLAN offload</strong></h2><p>将这一场景分为不启动网卡的VXLAN offload和启动网卡的VXLAN offload两种情况，并对内部的实现机制的不同进行对比分析。</p>
<h3 id="网卡不开启VXLAN-offload"><a href="#网卡不开启VXLAN-offload" class="headerlink" title="网卡不开启VXLAN offload"></a><strong>网卡不开启VXLAN offload</strong></h3><h4 id="计算节点"><a href="#计算节点" class="headerlink" title="计算节点"></a><strong>计算节点</strong></h4><img src="/images/vxlan-offload/LinuxBridgeOffVxlanCompute.png">
<p>从上图中可以看出，网包在计算节点有两个不同的流向，即从虚机内部出去的数据包以及进入虚机的数据包。</p>
<ul>
<li><strong>虚机内部出去的数据包</strong></li>
</ul>
<p>（1）虚机发出的二层帧数据包首先经过tap设备发送到Linux bridge进行处理；</p>
<p>（2）Linux bridge收到tap设备的二层帧后，首先进行security group的检查，如果满足预定安全组的设置，就交给与其连接的VXLAN interface；</p>
<p>（3）VXLAN interface先对二层帧进行检查，看是否超过MTU预先设定的值，如果超过预置MTU的大小就会进行分片处理，接着二层帧数据包会被Linux VXLAN kernel模块的注册的hook函数进行处理，扔给Linux VETP kernel模块；</p>
<p>（4）Linux VETP kernel模块的vxlan_xmit函数先判断是否需要进行ARP广播，然后就会将二层数据帧封装成udp package，然后调用系统接口处理；</p>
<p>（5）系统函数利用udp sockegt发送出VXLAN封装后的数据包，直接扔给网卡NIC，经过NIC发送到外面去，当然也需要对MTU进行判断，如果超出大小就会进行分片处理。</p>
<ul>
<li><strong>进入虚机的数据包</strong></li>
</ul>
<p>（1） 在计算节点，进入虚机的数据包首先经过网卡NIC，在满足MTU的情况下，网卡NIC将数据包交给UDP Socket进行处理，并给到Linux VTEP kernel里去；</p>
<p>（2）Linux VXLAN kernel模块在udp协议栈上注册hook函数，该函数对接收到的数据帧做简单检查，再交给内核模块中专门处理VXLAN的函数vxlan_rcv；</p>
<p>（3）函数vxlan_rcv先判断该VXLAN的数据包是否存在VNI号，然后就进行VXLAN的数据包的解包，接着就调用系统接口，将解包后的二层帧数据扔到VXLAN interface；</p>
<p>（4）VXLAN interface需要重新计算MTU的大小，如果超过预定的设置后，就会对二层帧数据包进行分片，接着将帧数据扔给Linux bridge，进行正常的数据包的转发；</p>
<p>（5）Linux bridge收到二层帧数据包后，首先进行security group的检测，如果满足预先设定的安全组规则，就转发给桥上的tap设备，tap设备再将网包扔给所连接的虚机的tap接口，最终到达虚机。</p>
<h4 id="网络节点"><a href="#网络节点" class="headerlink" title="网络节点"></a><strong>网络节点</strong></h4><img src="/images/vxlan-offload/LinuxBridgeOffVxlanNetwork.png">
<p>在网络节点转发的数据包也分为两个方向</p>
<ul>
<li><strong>发送到外网的数据包</strong></li>
</ul>
<p>（1） 在网络节点，发往外网的数据包首先经过网卡NIC，在满足预先设定的MTU的情况下，网卡NIC将数据包交给UDP Socket进行处理，并给到Linux VTEP kernel里去；</p>
<p>（2）Linux VXLAN kernel模块在udp协议栈上注册hook函数，该函数对接收到的数据帧做简单检查，再交给内核模块中专门处理VXLAN的函数vxlan_rcv；</p>
<p>（3）函数vxlan_rcv先判断该VXLAN的数据包是否存在VNI号，然后就进行VXLAN的数据包的解包，接着就调用系统接口，将解包后的二层帧数据扔到VXLAN interface；</p>
<p>（4）VXLAN interface需要重新计算MTU的大小，如果超过预定的设置后，就会对二层帧数据包进行分片，接着将帧数据扔给Linux bridge，进行正常的数据包的转发；</p>
<p>（5）Linux bridge收到二层帧数据包后转发给桥上的tap设备，tap设备再将网包扔给所连接的router的qr接口，route利用NAT转换将数据包通过qg接口扔给br-ex网桥；</p>
<p>（6）br-ex网桥接收到网包后通过网口ethX发送到外网去；</p>
<ul>
<li><strong>从外网进来的数据包</strong></li>
</ul>
<p>（1）外网过来的数据包先经过router，router根据分配给虚机的floating ip，将数据包扔给Linux bridge；</p>
<p>（2）Linux bridge收到tap设备的二层帧后交给与其连接的VXLAN interface；</p>
<p>（3）VXLAN interface先对二层帧进行检查，看是否超过预先设定的值，如果超过大小就会进行分片处理，接着二层帧数据包会被Linux VXLAN kernel模块的注册的hook函数进行处理，扔给Linux VETP kernel模块；</p>
<p>（4）Linux VETP kernel模块的vxlan_xmit函数先判断是否需要进行ARP广播，然后就会将二层数据帧封装成udp package，然后调用系统接口处理；</p>
<p>（5）系统函数利用udp sockegt发送出VXLAN封装后的数据包，直接扔给网卡NIC，经过网卡NIC发送到外面去。</p>
<h4 id="总体原理框图"><a href="#总体原理框图" class="headerlink" title="总体原理框图"></a><strong>总体原理框图</strong></h4><img src="/images/vxlan-offload/LinuxBridgeOffVxlanAll.png">
<h3 id="网卡开启VXLAN-offload"><a href="#网卡开启VXLAN-offload" class="headerlink" title="网卡开启VXLAN offload"></a><strong>网卡开启VXLAN offload</strong></h3><h4 id="计算节点-1"><a href="#计算节点-1" class="headerlink" title="计算节点"></a><strong>计算节点</strong></h4><img src="/images/vxlan-offload/LinuxBridgeOnVxlanCompute.png">
<p>从图上可以看出，网包在计算节点需要进行两个方面的考虑，从虚机内部出去的数据包以及进入虚机的数据包。</p>
<ul>
<li><strong>虚机内部出去的数据包</strong></li>
</ul>
<p>（1）虚机发出的二层帧数据包首先经过tap设备发送到Linux bridge进行处理；</p>
<p>（2）Linux bridge接受tap设备的二层帧数据包，首先检测是否满足security group，如果满足安全组的规则，扔给启动VXLAN offload功能的网卡NIC；</p>
<p>（3）NIC在满足预定大小的MTU条件下，直接对二层帧数据包进行VXLAN的offload处理，并把带有VXLAN header的数据包扔给leaf交换机，如果超过了MTU，先对网包进行分片再进行处理；</p>
<ul>
<li><strong>进入虚机的数据包</strong></li>
</ul>
<p>（1） 在计算节点，从leaf交换机进入虚机的数据包首先经过网卡NIC，在满足MTU的情况下，对带有VXLAN header的网包进行VXLAN的offload，如果网络包大小超过了MTU，那么NIC利用TSO或者USO对网包进行分片处理；</p>
<p>（2）经过NIC处理后的二层帧数据包直接扔给Linux bridge进行处理；</p>
<p>（3）Linux bridge收到二层帧数据包后，首先检测是否满足security group，如果满足安全组的规则，转发给桥上的tap设备，tap设备再将网包扔给所连接的虚机的tap接口，最终到达虚机。</p>
<h4 id="网络节点-1"><a href="#网络节点-1" class="headerlink" title="网络节点"></a><strong>网络节点</strong></h4><img src="/images/vxlan-offload/LinuxBridgeOnVxlanNetwork.png">
<p>在网络节点转发的数据包也分为两个方向</p>
<ul>
<li><strong>发送到外网的数据包</strong></li>
</ul>
<p>（1） 在网络节点，发往外网的数据包首先从leaf交换机进入虚机的数据包首先经过网卡NIC，在满足MTU的情况下，对带有VXLAN header的网包进行VXLAN的offload，如果网络包大小超过了MTU，那么NIC利用TSO或者USO对网包进行分片处理；</p>
<p>（2）经过NIC处理后的二层帧数据包直接扔给Linux bridge进行处理；</p>
<p>（3）Linux bridge收到二层帧数据包后转发给桥上的tap设备，tap设备再将网包扔给所连接的router的qr接口，route利用NAT转换将数据包通过qg接口扔给br-ex网桥；</p>
<p>（4）br-ex网桥接收到网包后通过网口ethX发送到外网去；</p>
<ul>
<li><strong>从外网进来的数据包</strong></li>
</ul>
<p>（1）外网过来的数据包先经过router，router根据分配给虚机的floating ip，将数据包扔给Linux bridge；</p>
<p>（2）Linux bridge接受tap设备的二层帧数据包，扔给启动VXLAN offload功能的网卡NIC；</p>
<p>（3）NIC在满足预定大小的MTU条件下，直接对二层帧数据包进行VXLAN的offload处理，并把带有VXLAN header的数据包扔给leaf交换机，如果超过了MTU，先对网包进行分片再进行处理；</p>
<h4 id="总体框图"><a href="#总体框图" class="headerlink" title="总体框图"></a><strong>总体框图</strong></h4><img src="/images/vxlan-offload/LinuxBridgeOnVxlanAll.png">
<h2 id="Neutron-VXLAN-openVswitch中的NIC-VXLAN-offload"><a href="#Neutron-VXLAN-openVswitch中的NIC-VXLAN-offload" class="headerlink" title="Neutron VXLAN +openVswitch中的NIC VXLAN offload"></a><strong>Neutron VXLAN +openVswitch中的NIC VXLAN offload</strong></h2><p>   在这种场景下也可以分为两种情况进行讨论，NIC不开启VXLAN offload和开启VXLAN offload，对于不开启VXLAN offload的情况，即为传统上neutron的VXLAN的实现方案，具体<a href="http://chyufly.github.io/blog/2016/07/11/understanding-neutron-vlan-vxlan/" target="_blank" rel="external">参见这里</a>，下面主要介绍NIC在开启VXLAN offload情况下的网络数据通信机制。也是将网包分为两个方向进行说明，一种是网络数据包从虚机发出，另外一种就是网络数据包从外面发送到虚机里面去。</p>
<h3 id="计算节点-2"><a href="#计算节点-2" class="headerlink" title="计算节点"></a><strong>计算节点</strong></h3><p>原理框图如下所示：</p>
<img src="/images/vxlan-offload/OVSOnVxlanCompute.png">
<h4 id="Linux-bridge和br-int"><a href="#Linux-bridge和br-int" class="headerlink" title="Linux bridge和br-int"></a><strong>Linux bridge和br-int</strong></h4><p>  在计算节点上，OVS的br-int主要进行vlan标签的设置和转发，而开启VXLAN offload功能的NIC主要用于vxlan标签的设置和转发流量。</p>
<p>  在OVS中，利用网桥br-int来对vlan和mac进行转发，作为一个二层交换机使用，主要的接口包含两类：linux bridge过来的qvo-xxx以及往外的patch-tun接口，连接到br-tun<br>网桥。这样就可以通过qvo-xxx 接口上为每个经过的网络分配一个内部 vlan的tag，如果在同一个neutron网络里启动了多台虚机，那么它们的tag都是一样的，如果是在不同的网络，那么vlan tag就会不一样。</p>
<h4 id="NIC的VXLAN-offload"><a href="#NIC的VXLAN-offload" class="headerlink" title="NIC的VXLAN offload"></a><strong>NIC的VXLAN offload</strong></h4><p>neutron中的vxlan的offload主要在NIC中完成，利用NIC driver实现带有VXLAN header的网包在leaf交换机上进行正常的转发，可以从两个维度来进行思考：</p>
<p>（1）从vm内部过来的数据包从br-int网桥过来，NIC对数据包进行VXLAN header处理，并将处理后的udp package扔给连接的leaf交换机；</p>
<p>（2）数据包从外面public network经过leaf交换机过来的VXLAN的网络包，首先判断该VXLAN的数据包是否存在VNI号，然后就进行VXLAN的数据包的解包，将解包后的二层帧数<br>据扔到br-int上去；</p>
<h3 id="网络节点-2"><a href="#网络节点-2" class="headerlink" title="网络节点"></a><strong>网络节点</strong></h3><p>原理框图如下所示：</p>
<img src="/images/vxlan-offload/OVSOnVxlanNetwork.png">
<p>在网络节点上，所部署的neutron服务主要包括DHCP服务和路由服务等，网桥主要包括OVS的br-int，Linux bridge和br-ex等。</p>
<h4 id="NIC的VXLAN-offload-1"><a href="#NIC的VXLAN-offload-1" class="headerlink" title="NIC的VXLAN offload"></a><strong>NIC的VXLAN offload</strong></h4><p>网络节点的VXLAN的offload主要由NIC来实现，主要实现udp package的封装和解封，可以从两个维度来进行思考：</p>
<p>（1）从虚机内部经过leaf交换机过来的VXLAN的网络包，首先判断该VXLAN的数据包是否存在VNI号，然后就进行VXLAN的数据包的解包，将解包后的二层帧数据扔到br-int上去<br>；</p>
<p>（2）二层帧数据包从br-int网桥过来，NIC对数据包进行VXLAN header处理，并将处理后的udp package扔给连接的leaf交换机。</p>
<h4 id="Linux-bridge和br-int-1"><a href="#Linux-bridge和br-int-1" class="headerlink" title="Linux bridge和br-int"></a><strong>Linux bridge和br-int</strong></h4><p>   在网络节点上，vlan tag的设置主要在br-int网桥上进行，作为一个正常的二层交换设备进行使用，只是根据vlan和mac进行数据包的转发。接口类型包括：</p>
<p>（1）tap-xxx，连接到网络 DHCP 服务的命名空间；</p>
<p>（2）qr-xxx，连接到路由服务的命名空间；</p>
<p>  如图所示，如果br-int从qr-XXX进入的网包，就会打上VLAN tag为15，发送到br-tun上去，如果网包带有VLAN tag为15，则直接从qr-XXX口进到router服务中去。主要通过br-ex网桥和public network进行通信，一个是挂载的物理接口上，如 ens160，网包将从这个接口发送到外部网络上。</p>
<p>  另外一个是 qg-xxx 这样的接口，是连接到 router 服务的网络名字空间中，里面绑定一个路由器的外部 IP，作为 NAT 时候的地址，另外，网络中的 floating IP 也放在这个网络名字空间中。</p>
<h4 id="router和DHCP"><a href="#router和DHCP" class="headerlink" title="router和DHCP"></a><strong>router和DHCP</strong></h4><p>   dhcp服务是通过dnsmasq进程（轻量级服务器，可以提供dns、dhcp、tftp等服务）来实现的，该进程绑定到dhcp名字空间中的br-int的接口上。neutron中的路由服务主要<br>提供跨子网间的网络通信，包括虚拟想访问外部网络等。路由服务主要利用namespace实现不同网络之间的隔离性。另外，router还可以实现tenant work和external network之间的网络连接，通过SNAT实现tenant network往external network的网络连通性（fixed IP），通过DNAT实现external network往tenant network的网络连通性（floating IP）。</p>
<h4 id="总体框图-1"><a href="#总体框图-1" class="headerlink" title="总体框图"></a><strong>总体框图</strong></h4><img src="/images/vxlan-offload/OVSOnVxlanAll.png">

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/26/2016-11-26-vxlan-offload-intro/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yuchenghui">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="于成辉的技术博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="于成辉的技术博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/26/2016-11-26-vxlan-offload-intro/" itemprop="url">
                  网卡VXLAN的offload技术介绍和概念解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-26T11:45:21+08:00">
                2016-11-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/云计算/" itemprop="url" rel="index">
                    <span itemprop="name">云计算</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h2 id="offload技术概述"><a href="#offload技术概述" class="headerlink" title="offload技术概述"></a><strong>offload技术概述</strong></h2><p>   首先要从术语offload说起，offload指的是将一个本来有软件实现的功能放到硬件上来实现，这样就可以将本来在操作系统上进行的一些数据包处理（如分片、重组等）放到网卡硬件上去做，降低系统CPU消耗的同时，提高处理性能。在neutron中，基于VXLAN的网络虚拟技术给服务器的CPU带来了额外的负担，比如封包、解包和校验等，VXLAN的封包和解包都是由OVS来完成的，使用VXLAN offload技术后，VXLAN的封包和解包都交给网卡或者硬件交换机来做了，那么网卡的VXLAN offload技术就是利用网卡来实现VXLAN的封包和解包功能。</p>
<p>再说技术分类，实现offload的几种技术：</p>
<ul>
<li><p>LSO（Large Segment Offload）：协议栈直接传递打包给网卡，由网卡负责分割</p>
</li>
<li><p>LRO（Large Receive Offload）：网卡对零散的小包进行拼装，返回给协议栈一个大包</p>
</li>
<li><p>GSO（Generic Segmentation Offload）：LSO需要用户区分网卡是否支持该功能，GSO则会自动判断，如果支持则启用LSO，否则不启用</p>
</li>
<li><p>GRO（Generic Receive Offload）：LRO需要用户区分网卡是否支持该功能，GRO则会自动判断，如果支持则启用LRO，否则不启用</p>
</li>
<li><p>TSO（TCP Segmentation Offload）：针对TCP的分片的offload。类似LSO、GSO，但这里明确是针对TCP</p>
</li>
<li><p>USO（UDP Segmentation offload）：正对UDP的offload，一般是IP层面的分片处理</p>
</li>
</ul>
<h3 id="几种技术的对比"><a href="#几种技术的对比" class="headerlink" title="几种技术的对比"></a><strong>几种技术的对比</strong></h3><p><strong>（1）LSO vs LRO</strong></p>
<p>  两种技术分别对应发送数据和接收数据两个方面，一般来说，计算机网络上传输的数据基本单位是离散的数据包，而且这个数据包都有MTU的大小的限制，如果需要发送比较多的数据，那么经过OS协议栈的时候，就会拆分为不超过MTU的数据包，如果使用CPU来做的话，会造成使用率过高。引入LSO后，在发送数据超过MTU的时候，OS只需要提交一次请求给网卡，网卡会自动把数据拿过来，然后进行拆分封装，发送的数据包不会超过MTU的限制，而LRO的作用就是当网卡一次收到很多碎片数据包时，LRO可以辅助自动组合成一段较大的数据包，一次性的交给OS处理，这两种技术主要面向TCP报文。</p>
<p><strong>（2）TSO vs UFO</strong></p>
<p>  分别对应TCP报文和UDP报文，TSO 将 TCP 协议的一些处理下放到网卡完成以减轻协议栈处理占用 CPU 的负载。通常以太网的 MTU 是1500Bytes，除去 IP 头（标准情况下20<br>Bytes）、TCP头（标准情况下20Bytes），TCP的MSS (Max Segment Size)大小是1460Bytes。当应用层下发的数据超过 MSS 时，协议栈会对这样的 payload 进行分片，保证生成的报文长度不超过MTU的大小。但是对于支持 TSO/GSO 的网卡而言，就没这个必要了，可以把最多64K大小的 payload 直接往下传给协议栈，此时 IP 层也不会进行分片，一直会传给网卡驱动，支持TSO/GSO的网卡会自己生成TCP/IP包头和帧头，这样可以offload很多协议栈上的内存操作，checksum计算等原本靠CPU来做的工作都移给了网卡。</p>
<h2 id="NIC的VXLAN-offload技术介绍"><a href="#NIC的VXLAN-offload技术介绍" class="headerlink" title="NIC的VXLAN offload技术介绍"></a><strong>NIC的VXLAN offload技术介绍</strong></h2><img src="/images/vxlan-offload/vxlan-offload-intro-1.png">
<p>  上面主要介绍了一些offload技术的基本概念，下面来详细介绍VXLAN的offload原理。<br>  在虚拟化的网络覆盖应用中存在多种技术，主要包括VXLAN、NVGRE和SST等隧道技术，以VXLAN技术为例，采用MAC-in-UDP来进行数据包的转换传输，从上图可以看出，除了UDP协议报头，VXLAN还引入额外的数据包处理，这种添加或者移除协议包头的操作使CPU需要执行关于数据包的更多操作。目前来看，Linux driver已经可满足硬件网卡的VXLAN offload需求，使用下面的ethtool命令就可以配置网卡的VXLAN offload功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ethtool -k ethX //这项命令可以列举出ethX的offloads以及当前的状态</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ethtool -K ethX tx-udp_tnl-segmentation [off|on] //可以开启或关闭Linux</div></pre></td></tr></table></figure>
<p>  采用网卡VXLAN offload技术后，overlay情形下的虚拟网络性能也会得到大规模的提升。本质上来说，VXLAN的封装格式类似于一种l2vpn技术，即将二层以太网报文封装在udp报文里，从而跨越underlay L3网络，来实现不同的服务器或不同的数据中心间的互联。</p>
<p>  在采用VXLAN技术后，由于虚机产生或接受的报文被封装于外层的UDP报文中予以传输，使得以往的TCP segment optimization、TCP checksum offload等功能对于内层的虚机的TCP数据收发失效，较大的影响了虚机间通信的性能，给最终的用户带来了很差的用户体验。厂商为了解决上述问题，提出了NIC VXLAN offload技术。</p>
<p>  网卡的VXLAN offload主要对网卡的能力进行了增强，并与网卡驱动配合，使得网卡能够知晓VXLAN内部以太报文的位置，从而使得TSO、TCP checksum offload这些技术能够对内部的以太报文生效，从而提升TCP性能。</p>
<img src="/images/vxlan-offload/vxlan-offload-intro-2.png">
<p>  目前部署虚拟网络主流采用VXALN技术，其封包、解包用CPU来实现，将会消耗很大的CPU等系统资源。VXLAN使用通用的x86进行封包、解包处理，其CPU资源占用会达到50%左右，可以考虑使用支持VXLAN offload功能的网卡来降低系统资源的消耗问题。目前来看，博通、Intel、mellanox和Qlogic等网卡厂商都支持VXLAN的卸载。尽管是不同厂商的产品，但业内已经有标准的VXLAN offload接口，无需改动代码即可启用这一功能，并不会增加代码层面的工作量。</p>
<img src="/images/vxlan-offload/vxlan-offload-intro-3.png">
<p><strong><em><a href="http://www.testlab.com.cn/Index/article/id/1106.html" target="_blank" rel="external">图片来自青云SDN 2.0 NIC的VXLAN Offload的测试报告</a></em></strong></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/11/26/2016-11-26-devstack-and-GBP-setup/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yuchenghui">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="于成辉的技术博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="于成辉的技术博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/26/2016-11-26-devstack-and-GBP-setup/" itemprop="url">
                  devstack+GBP的环境安装
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-11-26T10:15:00+08:00">
                2016-11-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/云计算/" itemprop="url" rel="index">
                    <span itemprop="name">云计算</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p><strong>操作系统：CentOS7</strong><br><strong>openstack版本：liberty</strong></p>
<h2 id="首先安装基本的应用"><a href="#首先安装基本的应用" class="headerlink" title="首先安装基本的应用"></a>首先安装基本的应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install vim git wget cats</div></pre></td></tr></table></figure>
<h2 id="配置源（以阿里源为例），并禁用fastmirror插件"><a href="#配置源（以阿里源为例），并禁用fastmirror插件" class="headerlink" title="配置源（以阿里源为例），并禁用fastmirror插件"></a>配置源（以阿里源为例），并禁用fastmirror插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cd /etc/yum.repos.d/</div><div class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</div><div class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</div><div class="line">vim  /etc/yum/pluginconf.d/fastestmirror.conf      将enable=0</div><div class="line">yum clean all</div><div class="line">yum makecache</div><div class="line">yum update</div></pre></td></tr></table></figure>
<h2 id="安装pip，并配置豆瓣源"><a href="#安装pip，并配置豆瓣源" class="headerlink" title="安装pip，并配置豆瓣源"></a>安装pip，并配置豆瓣源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum -y install epel-release</div><div class="line">yum -y install python-pip</div><div class="line">vim /etc/pip.conf，</div></pre></td></tr></table></figure>
<p>添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[global]</div><div class="line">index-url = http://pypi.douban.com/simple/</div><div class="line">trusted-host = pypi.douban.com</div></pre></td></tr></table></figure>
<h2 id="下载L版devstack并打gbp-patch"><a href="#下载L版devstack并打gbp-patch" class="headerlink" title="下载L版devstack并打gbp-patch"></a>下载L版devstack并打gbp-patch</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone http://git.trystack.cn/openstack-dev/devstack -b stable/liberty</div><div class="line">cd /home</div><div class="line">git clone http://git.trystack.cn/openstack-dev/devstack.git -b stable/liberty</div></pre></td></tr></table></figure>
<h2 id="创建stack用户，并设置权限"><a href="#创建stack用户，并设置权限" class="headerlink" title="创建stack用户，并设置权限"></a>创建stack用户，并设置权限</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cd /home/devstack/tools/</div><div class="line">./create-stack-user.sh</div><div class="line">chown -R stack:stack /home/devstack</div><div class="line">chmod 777 /dev/pts/0</div><div class="line">su stack</div><div class="line">cd /home/devstack</div></pre></td></tr></table></figure>
<h2 id="下载GBP脚本"><a href="#下载GBP脚本" class="headerlink" title="下载GBP脚本"></a>下载GBP脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wget https://raw.githubusercontent.com/group-policy/gbp-devstack/liberty/gbp-patch.sh</div><div class="line">vim gbp-patch.sh，修改第八行的apache2为httpd（apache2是Ubuntu上的服务，centos对应为httpd）</div><div class="line">chmod +x gbp-patch.sh</div><div class="line">./gbp-patch.sh</div><div class="line">vim local.conf，修改其中的GIT_BASE为http://git.trystack.cn</div><div class="line">./stack.sh</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/07/23/2016-07-23-understanding-neutron-sdn/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="yuchenghui">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="于成辉的技术博客">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="于成辉的技术博客" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/07/23/2016-07-23-understanding-neutron-sdn/" itemprop="url">
                  SDN融合方案中，neutron底层网络运行机制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-07-23T09:52:22+08:00">
                2016-07-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/云计算/" itemprop="url" rel="index">
                    <span itemprop="name">云计算</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="服务部署情况"><a href="#服务部署情况" class="headerlink" title="服务部署情况"></a><strong>服务部署情况</strong></h1><p>一般而言，neutron-server和各neutron-plugin部署在控制节点或者网络节点上，而neutron agent则部署在网络节点上和计算节点上。我们先来简单地分析控制端neutron-server和neutron-plugin的工作，然后再分析设备端neutron-agent的工作。</p>
<h2 id="compute节点的部署情况"><a href="#compute节点的部署情况" class="headerlink" title="compute节点的部署情况"></a><strong>compute节点的部署情况</strong></h2><ul>
<li>keystone认证服务</li>
<li>nova-comput服务</li>
<li>OVS service和OVS-agent</li>
</ul>
<h2 id="network节点的部署情况"><a href="#network节点的部署情况" class="headerlink" title="network节点的部署情况"></a><strong>network节点的部署情况</strong></h2><ul>
<li>OVS service</li>
<li>OVS agent</li>
<li>L3 agent</li>
<li>DHCP agent</li>
<li>metadata agent</li>
<li>keystone服务</li>
</ul>
<h2 id="controller节点的部署情况"><a href="#controller节点的部署情况" class="headerlink" title="controller节点的部署情况"></a><strong>controller节点的部署情况</strong></h2><ul>
<li>SQL server</li>
<li>message queue</li>
<li>keystone service</li>
<li>neutron server</li>
<li>ml2 plugin</li>
</ul>
<img src="/images/understanding-neutron1/understanding_neutron_compute_controller_network_services.png">
<h1 id="neutron底层实现机制"><a href="#neutron底层实现机制" class="headerlink" title="neutron底层实现机制"></a><strong>neutron底层实现机制</strong></h1><h2 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a><strong>总体介绍</strong></h2><p>在neutron和SDN方案中，neutron底层网络的实现包括：</p>
<ul>
<li>agent是处理数据流的网络设备（OVS，Router，负载均衡等）</li>
<li>agent是SDN controller（ODL，ONOS等）</li>
</ul>
<p>具体关系包括两种类型，如图所示：</p>
<h3 id="第一种：neutron作为SDN-controller"><a href="#第一种：neutron作为SDN-controller" class="headerlink" title="第一种：neutron作为SDN controller"></a><strong>第一种：neutron作为SDN controller</strong></h3><img src="/images/understanding-neutron1/understanding_neutron_sdn_only_neutron.PNG">
<h3 id="第二种：neutron作为application"><a href="#第二种：neutron作为application" class="headerlink" title="第二种：neutron作为application"></a><strong>第二种：neutron作为application</strong></h3><p> 第一种类型：neutron相当于SDN控制器<br> 第二种类型：neutron作为SDN的应用，将业务告知给SDN controller，neutron的角色更多的是super controller或者网络编排器，来完成openstack中有关于网络业务的集中分发，将应用的RESTful API分发给相应的SDN进行处理。具体实现方法包括：</p>
<ul>
<li>特定的SDN controller plugin</li>
<li>ML2 plugin和定制的mechanism driver</li>
</ul>
<img src="/images/understanding-neutron1/understanding_neutron_sdn_notonly_neutron.PNG">
<h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a><strong>应用举例</strong></h2><p>openstack和SDN集成中，以openDayLight为例，可以通过实现mechanism driver来与neutron对接，利用ml2 plugin的北向 RESTful API实现功能。</p>
<p>通过一个openstack用户应用的调用为例进行说明（ml2配置的ODL的mechanism driver，以及一个VXLAN的driver）：</p>
<p>（1）用户在horizon界面发从对网络操作的一个请求，包装成RESTful API，并送给neutron server，这可以作为一个北向RESTful API；<br>（2）neutron server将RESTful API给到ml2 plugin，并会将配置信息同步给 neutron database（注：由于ODL driver并不实现pre commit,只实现post commit，会出现openstack的数据库和ODL数据库的不一致性）；<br>（3）ml2 plugin调用RESTFul API给到ODL controller；<br>（4）ODL接收到请求后，就会利用南向的plugins/网络协议（openFlow,OVSDB等）来对网络进行相应的操作。</p>
<img src="/images/understanding-neutron1/understanding_neutron_sdn_how_do.PNG">

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="yuchenghui" />
          <p class="site-author-name" itemprop="name">yuchenghui</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">39</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">yuchenghui</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  


</body>
</html>
